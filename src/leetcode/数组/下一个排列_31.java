package leetcode.数组;

import java.util.Arrays;

/**
 * @author ruxing.wrx
 * @date 2023/6/3 18:54
 */
public class 下一个排列_31 {
    /**
     * 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
     * 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
     * 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
     *
     * 如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：
     *
     * 1、   我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，
     *      就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
     * 2、   我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
     *      1、在 尽可能靠右的低位 进行交换，需要 从后向前 查找
     *      2、将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
     *      3、将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。
     *          以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。
     *          显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
     *
     */

    public void nextPermutation(int[] nums) {
        int len = nums.length;
        for (int i = len - 1; i > 0; i--) {
            // 从后往前找到比前一个数大的位置
            if (nums[i] > nums[i - 1]) {
                // 后面的数字排序
                Arrays.sort(nums, i, len);
                for (int j = i; j < len; j++) {
                    // 后面数字排序后，依次找比前一个数大的数，然后交换，返回结果
                    if (nums[j] > nums[i - 1]) {
                        int temp = nums[j];
                        nums[j] = nums[i - 1];
                        nums[i - 1] = temp;
                        return;
                    }
                }
            }
        }
        // 走到这说明，已经是最大的数了，排序一下返回最小的数
        Arrays.sort(nums);
    }
}
